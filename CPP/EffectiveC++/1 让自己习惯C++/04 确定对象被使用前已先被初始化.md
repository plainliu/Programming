> 确定对象被使用前已先被初始化

# 什么时候初始化

具体规则复杂，最好是在使用对象前初始化

- C风格的代码，如果会引起运行期的成本，则不保证初始化
- 非C风格，规则不一致



内置类型：

- 声明时初始化
- 利用输入进行初始化

其他类型：

- 构造函数负责初始化（确保每个成员被初始化）

# 构造函数成员初值列

赋值和初始化

- 在构造函数中设置变量的值，是赋值
- 构造函数的成员初值列进行初始化



执行顺序拆分

1. 分配对象内存

2. 是否初始化？

   - 内置类型，不一定初始化（看在哪里声明的）

   - 其他类型，初始化，调用构造函数

     - 成员变量初始化

       默认

       - 内置类型，不一定初始化
       - 其他类型，调用构造函数初始化

       **成员初值列**

       - 手动初始化
       - 为保证变量被初始化，减少后续使用负担，所有的变量包括内置类型，可以全部在这里初始化

     - 进构造函数体

       这时

       - 内置类型：不保证初始化，这里内置类型赋值和初始值列初始化成本相同。如果成员初值列中进行了初始化，则已初始化。
       - 其他类型，已经初始化。



对于一般类型，成员初值列中初始化比构造函数中赋值效率高。而且对于const变量或引用，只能初始化，不能赋值。



成员初值列中的初始化顺序

- 先基类，后子类
- 成员变量初始化顺序依赖于class中的声明顺序

# non-local static对象初始化

static对象：构造出来一直到程序结束销毁，不在stack或heap上

- non-local：global对象，namespace作用域中的对象，class内，file作用域内，被声明为static的对象
- local：函数类的static对象



如果同一个non-local static对象，需要在两个编译单元（生成两个obj）中用到，2中的初始化依赖1中初始化的static对象，那可能1没有被初始化。**编译单元的顺序不能确定。**



解决方案：

把non-local static对象转化为local static对象，用函数访问，采用单例的设计模式，保证访问前一定被初始化。

（访问单例的方法可以设计为inline增加速度）



多线程如果存在访问不确定性，则可以在程序单线程期间，全部调用一遍创建单例。

