> 14 在资源管理类中小心copying行为

# 问题

当一个RAII对象被复制，会发生什么

```c++
Mutex m;
{
    Lock m1(&m);
    Lock m2(m1); // copy ctor
}
```

# 解决方案

根据使用场景确定处理方式

## 禁止复制

将copying函数声明为private，或者继承Uncopyable

## 对底层资源祭出“引用计数法”

RAII class中用shared_ptr管理成员变量，复制时则带有计数行为。

需要注意：

- 计数减为0，shared_ptr的默认行为是释放，但锁资源需要的是解锁，所以需要指定智能指针的“**删除器**”。
- RAII class不再需要定义析构函数进行解锁，因为计数为0后，会调用删除器解锁。

## 复制底部资源

注意复制资源管理对象时，进行的是“**深度拷贝**”。

## 转移底部资源的拥有权

可能希望确保只有一个RAII对象指向一个未加工资源，复制时依然如此。

auto_ptr

