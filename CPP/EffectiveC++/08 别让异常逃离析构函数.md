> 别让异常逃离析构函数

# 问题

如果析构中发生异常并吐出异常，如下代码在释放vector时，如果v中有多个对象，且不止一个抛出异常，则会导致不明确行为。

```c++
{
    vector<Myclass> v;
}
```

两个异常同时存在的情况下，程序若不是结束执行就是导致不明确行为。（list、array、set都可能出现上述问题）

# 别让异常逃离析构函数

方法：

1. catch后退出程序

   ```c++
   C::~C()
   {
       try { ... }
       catch {
           std::abort();
       }
   }
   ```

   

   如果程序在析构发生异常后，不能继续执行，可以强迫结束

2. catch后吞下异常

   catch中记录后，仍继续运行

   前提：程序必须能可靠地运行，即使遇到并忽略一个错误后

   ```c++
   C::~C()
   {
       try { ... }
       catch {
           // 记录
       }
   }
   ```

   

3. 给客户提供处理异常的机会

   单独提供接口供客户使用，发生异常后，用户做处理

   ```c++
   C::close() // 供客户使用的新接口
   {
       ... //执行可能发生异常的内容
       close = true;
   }
   
   C::~C()
   {
       if (!close)
       {
           try { ... }
           catch {
               // 记录
           }
       }
   }
   ```

   把责任从析构转移到客户，但析构中保留调用

规则

- 析构函数不要吐出异常，吞下不传播或结束程序
- 如果某个操作可能存在失败时抛出异常，而又存在必须要处理的异常，那么这个异常必须来自析构以外的函数



思考

- 构造函数是否也不能吐出异常？

